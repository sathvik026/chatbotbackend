Prerequisites:

Kubernetes cluster running (EKS, GKE, or a local cluster like Minikube or K3s).

kubectl configured to interact with the cluster.

Persistent Volume support for stateful data.

Docker installed for containerization.

Step 1: Create a Persistent Volume (PV) and Persistent Volume Claim (PVC)

MySQL requires persistent storage to retain data. You need to create a PersistentVolume (PV) and PersistentVolumeClaim (PVC).

Persistent Volume (PV) YAML:
apiVersion: v1
kind: PersistentVolume
metadata:
  name: mysql-pv
spec:
  capacity:
    storage: 5Gi  # Adjust based on your needs
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: standard
  hostPath:  # For local cluster, you can use hostPath
    path: "/mnt/data/mysql"

Persistent Volume Claim (PVC) YAML:
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: standard
  resources:
    requests:
      storage: 5Gi  # Match this with PV capacity


Run the commands to apply the PV and PVC:

kubectl apply -f pv.yaml
kubectl apply -f pvc.yaml

Step 2: Create MySQL Deployment YAML

To create the MySQL container, we use a StatefulSet instead of a Deployment for ensuring persistence and scalability.

MySQL StatefulSet YAML:
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql
spec:
  serviceName: "mysql"
  replicas: 1  # Initially one replica
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
        - name: mysql
          image: mysql:5.7
          env:
            - name: MYSQL_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mysql-secret
                  key: mysql-password
          ports:
            - containerPort: 3306
          volumeMounts:
            - name: mysql-storage
              mountPath: /var/lib/mysql
  volumeClaimTemplates:
    - metadata:
        name: mysql-storage
      spec:
        accessModes: [ReadWriteOnce]
        resources:
          requests:
            storage: 5Gi


This will create a stateful MySQL instance with persistent storage. You can modify the number of replicas based on scaling needs (e.g., replicas: 3 for horizontal scaling).

Run the command:

kubectl apply -f mysql-statefulset.yaml

Step 3: Create a Secret for MySQL Root Password

To avoid exposing your password in plain text, you should create a Kubernetes Secret.

kubectl create secret generic mysql-secret --from-literal=mysql-password=<your-password>


This step is required to configure the root password for MySQL.

Step 4: Expose MySQL via Service

Create a Service to expose MySQL to other applications within the cluster.

MySQL Service YAML:
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
    - port: 3306
  clusterIP: None  # Headless service for StatefulSets
  selector:
    app: mysql


Run the command:

kubectl apply -f mysql-service.yaml

Step 5: Horizontal Scaling

You can scale MySQL by increasing the number of replicas in the StatefulSet. If you want to scale to 3 replicas, modify the replicas value:

replicas: 3


Then apply the changes:

kubectl apply -f mysql-statefulset.yaml


To manually scale the StatefulSet:

kubectl scale statefulset mysql --replicas=3

Step 6: Verify MySQL Pods and Scaling

Check the status of the pods and ensure that the replicas are running:

kubectl get pods -l app=mysql


Check the state of the service:

kubectl get svc mysql


You should see multiple MySQL pods if scaling is successful.

Step 7: Check MySQL Connectivity

You can test the connectivity by accessing the MySQL pod. Run the following:

kubectl exec -it <mysql-pod-name> -- mysql -u root -p

Step 8: Enable Vertical Scaling (Optional)

If you need to scale vertically (increase CPU/memory), modify the resources in the StatefulSet:

resources:
  requests:
    memory: "1Gi"
    cpu: "500m"
  limits:
    memory: "2Gi"
    cpu: "1"


Then apply the updated configuration:

kubectl apply -f mysql-statefulset.yaml

Step 9: Monitoring and Logs

Use tools like Prometheus or Datadog to monitor the scaling performance of MySQL. Also, you can view the logs for troubleshooting:

kubectl logs <mysql-pod-name>

Step 10: Cleanup (Optional)

To delete all resources created:

kubectl delete -f mysql-statefulset.yaml
kubectl delete -f mysql-service.yaml
kubectl delete -f pv.yaml
kubectl delete -f pvc.yaml
kubectl delete secret mysql-secret
